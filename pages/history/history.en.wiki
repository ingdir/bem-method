==The History of BEM

Once upon a time, in a distant country far-far away, there was an IT company named Yandex that was busy developing web search and affiliated services. Services were numerous and growing, and more and more developers put their tireless efforts into improving the ecosystem of Yandex. Great things they did, and amazing tools they built, making their developers' lives easier, and times now have come to share that knowledge with the community, to embrace the magic power of Open Source and benefit all good people around.

This article tells about Yandex frontend developers constantly revising and improving the way they build web pages. Frontend developers are well known for their enormous curiosuty (that often brings innovation) and their remarkable lazyness that makes them devise sophisticated systems to save the precious time, to unify and automate everything.

This is how BEM was born into life, but before that, let's travel back in time to 2005 and sneak a peek over a shoulder of a really-really-busy Yandex frontend developer, and thus see...

=== ...Where It All Began

Back in 2005, a typical Yandex project contained a set of static HTML pages that served as a base reference for creating advanced templates like XSL stylesheets. These pages were in a separate folder and looked like this after a checkout:

%%hl xml
about.html
index.html
…
project.css
project.js
i/
    yandex.png
%%

There was a static HTML file for each page, with all the CSS pushed into a single stylesheet, ##project.css##, and all Javascript placed in a single ##project.js##; both files were shared between project pages. At those times, JavaScript was only sparsely applied to some controls, so all the interaction magic for the whole project could fit comfortably into a single small file.

Images were placed into a separate folder, as they were many. With IE 5 roaming in the wild and no CSS3, images were used for all sorts of eye-candy, even for creating rounded corners (although none of the youngest web developers would probably believe in that :)).

To keep some structure, style definitions for different page sections were separated using plain CSS comments like this:


%%hl xml
/* Content container (begin) */
    #body
        {
            font: 0.8em Arial, sans-serif;

            margin: 0.5em 1.95% 0.5em 2%;
        }
/* Content container (end) */

/* Graphical banner (begin) */
    .banner
        {
            text-align: center;
        }

    .banner a
        {
            text-decoration: none;
        }
/* Graphical banner (end) */
%%

Both IDs and classnames were used in the HTML markup.

Static HTML was manually copied into XSL stylesheets to be used in production, and all changes were synced two-way, manually. That was hard, and even when it wasn't hard, it was dull.

===Mid-scale projects

At the beginning of 2006, the first version of Yandex.Music had been under heavily development. Multiple pages, each unlike the other, didn't fit well into familiar simplistic concepts. Dozens of CSS classes you had to invent meaningful names for, a growing number of unintentional dependencies spread along the project--all that called for a better solution.

Typical piece of CSS code from those days:

%%hl xml
    /* Albums (begin) */
        .result .albums .info
            {
                padding-right: 8.5em;
            }

        .result .albums .title
            {
                float: left;

                padding-bottom: 0.3em;
            }

        .result .albums .album .listen
            {
                float: left;

                padding: 0.3em 1em 0 1em;
            }

        .result .albums .album .buy
            {
                float: left;

                padding: 0.4em 1em 0 1.6em;
            }

        .result .albums .info i
            {
                font-size: 85%;
            }
    /* Albums (end) */
%%

See that long cascade rules are used throughout the code.

Have another look:

%%hl xml
    /* Background images (begin) */
        .b-foot div
            {
                height: 71px;

                background: transparent url(../i/foot-1.png) 4% 50% no-repeat;
            }

        .b-foot div div
            {
                background-position: 21%;
                background-image: url(../i/foot-2.png);
            }

        .b-foot div div div
            {
                background-position: 38%;
                background-image: url(../i/foot-3.png);
            }

        .b-foot div div div div
            {
                background-position: 54%;
                background-image: url(../i/foot-4.png);
            }

        .b-foot div div div div div
            {
                background-position: 71%;
                background-image: url(../i/foot-5.png);
            }

        .b-foot div div div div div div
            {
                background-position: 87%;
                background-image: url(../i/foot-6.png);
            }
    /* Background images (end) */
%%

See that ##id## and tag names selectors are often part of a CSS rule.

At the same time, even bigger project was started ((http://wow.yandex.ru Яру))---a blogging platform, a place for people to interact, to share, to read and to engage.\\
There were dozens of various pages to support, and with the old-fashioned approach the code run out of control on many levels.

====Blocks To The Rescue
We needed to specify a data domain for managing page interface objects. This was a methodology thing, we needed to put more clarity into the way we work with concepts like ##class##, ##tag##, ##visual component## etc.

A new term was created: ##block##. Block is a part of a page design or layout having its specific and unique meaning defined either semantically, or visually.

CSS classes for blocks got prefixes (##b-##, ##c-##, ##g-##) to provide sort of a namespace emulation in CSS.

Prefixes explained:
 * **b-**  block\\
   an independent block, placed on a page wherever you need it
 * **с-**  control\\
   a control (an independent block) with a JavaScript object bound to it
 * **g-**  global\\
   a global definition, used sparingly and always defined for a specific, unique reason; the number of these definitions was kept at a minimum.

Some suffixes were employed as well, e.g.:
 * **-nojs**   no javascript\\
   Style rule to be applied with JavaScript turned off.
   The onload callback may contain ##init()## function call that removes these suffixes from all objects, thus semantically marking them up as "JavaScript-enabled".

====The Elements Appear

The inner classes of a block (or the corresponding DOM nodes inside) got a specific name and were now referred to as "elements".

The core distinction between a block and an element is the element's inability to exist out of its parent block's context. As long as you cannot separate something from a block, it's an element; when you can, then it's probably another block that needs another name.

In the styesheets, elements with lots of CSS got extra indentation and were wrapped in comments:

%%hl xml
    /* Head (begin) */
        .b-head { … }

        /* Logo (begin) */
            .b-head .logo { … }
            .b-head .logo a { … }
        /* Logo (end) */

        /* Right side (begin) */
        .b-head .right { … }

            /* Info (begin) */
                .b-head .info { … }
                .b-head .info .exit a { … }
            /* Info (end) */

            /* Search (begin) */
                .b-head .search { … }
                .b-head .search div div, .b-head .search div div i { … }
            /* Search (end) */
        /* Right side (end) */
    /* Head (end) */
%%

====Project File Structure Evolves
Larger projects took advantage of a more granular file structure. Our tremendous love for IE produced specific CSS files with workarounds and hacks that were loaded with conditional comments. JavaScript was employed even more, we got optional components and libraries. So, CSS and JS files got their separate folders.

%%hl xml
index.html
css/
    yaru.css
    yaru-ie.css
js/
    yaru.js
i/
    yandex.png
%%

MSIE-specific hacks could go into the main CSS file (##yaru.css##) if they were in compliance with the CSS standards:

%%hl xml
    /* Common definitions (begin) */
        body
            {
                font-family: Arial, sans-serif;
                font-size: 0.8em;

                padding: 0 0 2em 0;
                background: #fff;
            }

        * html body
            {
                font-size: 80%;
            }
%%

Non-valid workarounds were put in a standalone ##yaru-ie.css##.

%%hl xml
    /* Common blocks (begin) */
        /* Artist (begin) */
            .b-artist .i i
                {
                    top: expression(7 + (90 - this.parentNode.getElementsByTagName('img')[0].height)/2);
                    filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='../i/sticker-lt.png', sizingMethod='crop');
                }
%%

===Building Up A Framework: The Beginning

Designing similar projects eventually leads to re-creating the same blocks over and over again.

Careless copy/paste from project to project doesn't work well, for obvious reasons; you start compiling a collection of reusable components, which was referred to as a "common blocks library" inside our company, or simply "the Common".

First page fragments to be unified were: header, footer and some typographic CSS definitions. The corresponding files were hosted on a dedicated server.

Styles could be imported:

%%hl xml
@import url(http://common.cloudkill.yandex.ru/css/global.css);
@import url(http://common.cloudkill.yandex.ru/css/head/common.css);
@import url(http://common.cloudkill.yandex.ru/css/static-text.css);
@import url(http://common.cloudkill.yandex.ru/css/foot/common-absolute.css);
@import url(http://common.cloudkill.yandex.ru/css/foot/common-absolute-4-columns.css);
@import url(http://common.cloudkill.yandex.ru/css/list/hlist.css);
@import url(http://common.cloudkill.yandex.ru/css/list/hlist-middot.css);
@import url(http://common.cloudkill.yandex.ru/css/dropdown/dropdown.css);
@import url(http://common.cloudkill.yandex.ru/css/dropdown/dropdown-arrow.css);
@import url(slider.css);

/* Header (begin) */
    /* Service (begin) */
        .b-head .service h1 { … }
        .b-head .service h1, .b-head .service h1 a, .b-head .service h1 b { … }
%%

From this point onwards, styles have to be compiled before deployment; ##@import## directives are replaced with the actual contents of external files.

===Independent Blocks as a Concept
By the fall of 2007, the principles we were using to build our pages took their shape to produce the Independent Block concept, which was featured at the ClientSide'2007 conference:
«((http://vitaly.harisov.name/article/independent-blocks.html Independent blocks in HTML))»

In that presentation, the first attempt to define a ##block## has been made:
 * Block is a page fragment described by its own markup and styles.

For more details, see: ((http://clubs.ya.ru/bem/replies.xml?item_no=42))

==== Blocks: The Declaration of Independence
For the first time in several years, we tried to define some basic rules for independent blocks:

 1. Only classnames (not IDs) are used to describe styles;
 1. Each block's classname has a prefix;
 1. Every CSS rule must belong to a block.

As soon as unique IDs are dropped, the same block can be used on the same page more than once. This also allows two or more classes to co-exist on the same DOM node, which turned out to be quite useful later.

=====Blocks simple and compound

We defined simple blocks as not being able to contain another block anywhere inside their markup.
Compound blocks were allowed to have nested blocks in them.

This classification was naive; even the simplest blocks sometimes were wrapped around other blocks and had to be "upgraded" and refactored to fit the new role.

=====Completely Independent Blocks
CSS definitions aren't bulletproof when we mix a lot of styled content originating from different sources on a single web page. In complex layouts, blocks may alter each other's appearance because of element names conflicts. Tagname-based CSS rules may match more tags than we intended them to. As soon as we had to fight these and similar bugs in production, a strict version of an independent block (named Absolutely Independept Block, abbreviated AIB) was defined with the following extra rules:

 1. never match CSS to tagnames, use classnames for everything:\\
    ##.b-user b -> .b-user .first-letter##
 2. classnames for block elements must be prefixed with the parent block name:\\
    ##.b-user .first-letter -> .b-user-first_letter##

Such classnames tend to be much longer, and the resulting HTML code is considerably bigger in size.\\
This was the main reason why AIB was considered a "costly solution" to be used more as a remedy, not as an everyday practice.

=====Prefixes
As everybody is aware nowadays, giving names to variables is one of the most difficult problems in development, ever.
We approached it cautiously, and invented four prefixes allowed for block names, each with its own semantics.

 * **b-**\\
   common blocks
 * **h-**\\
   holsters, used for gluing several elements together
 * **l-**\\
   layout grids
 * **g-**\\
   global styles

=====Modifications

There are two legitimate sources of modification for a block:

 1. Block may alter its presentation according to its placement in the layout.
    Such modification is called ##context-dependent##.
 1. An additional (postfixed) classname may change block's appearance. This is a context-independent (postfix-based) modification.\\
##class="b-block b-block-postfix"##

===Unified Portal-Wide Framework
At the beginning of 2008, Yandex was reviewing its internal design policies and decided to prepare a brand book (for internal use) to enforce best practices in interface design.

This task was assigned to my team, and after some pondering of options, I decided to proceed with the one I was most proficient with: HTML and CSS code.\\
Interfaces evolve fast, and any attempt to describe interfaces with words and pictures will become obsolete even before completion. We needed a brand book that would represent our interfaces as they were: changing rapidly and still unified between different Yandex services and products.

Therefore, we decided that our interface brand book should be built with the same blocks we used to build our web sites. Blocks could be shared between projects and represent the latest in Yandex interface design.

We decided to build a portal-wide framework of blocks so all could both benefit from it and contribute back. The project was internally named ##Lego##.

====Структура репозитория Лего
Первичное разделение на верхнем уровне репозитория идёт по технологиям.

%%hl xml
css/
html/
js/
xml/
xsl/
%%

В каждой технологии своя структура.

CSS раскладывается в три разные директории:

%%hl xml
css/
    block/
        b-dropdown/
            b-dropdown.css
    service/
        auto/
            block/
                b-head-logo-auto.css
            head.css
    util/
        b-hmenu/
            b-hmenu.css
%%

 1. block -- общепортальные блоки
 1. util -- блоки, которые имеют смысл вне Яндекса, их можно выложить в OpenSource
 1. service -- стили для конкретных сервисов Яндекса, подключив их на сервис можно отобразить шапку, подвал

Структура директории html аналогична css.

%%hl xml
html/
    block/
        b-dropdown.html
    service/
        auto/
            l-head.html
    util/
        b-hmenu.html
%%

JS находится в зачаточном состоянии:

%%hl xml
js/
    check-is-frame.js
    check-session.js
    clean-on-focus.js
    dropdown.js
    event.add.js
    event.del.js
%%

У каждого сервиса есть XML-файл, использующийся для построения шапки.

%%hl xml
xml/
    block/
        b-head-tabs-communication.xml
        common-services.ru.xml
        head-messages.ru.xml
    service/
        auto/
            head.xml
%%

XSL блоков лежит в одной директории:

%%hl xml
xsl/
    block/
        b-dropdown.xsl
        b-head-line.xsl
        i-common.xsl
        i-locale.xsl
        l-foot.xsl
        l-head.xsl
%%

Каждому блоку соответствует один файл.

Подключение Лего на проекты делалось через svn:externals.

При сборке для продакшена, код библиотеки полностью включается в проект,
что можно сравнить со статической линковкой.

Такой подход позволяет выпускать версии сервисов с разными версиями Лего
и переходить на новую версию, когда это удобно команде проекта.\\
Мы используем его до сих пор.

=====Файлы страниц
Файлы, подключавшиеся на страницах, состояли из @import'ов реализации блоков.

%%hl xml
@import url(../../block/l-head/l-head.css);
@import url(../../block/b-head-logo/b-head-logo.css);
@import url(../../block/b-head-logo/b-head-logo_name.css);
@import url(block/b-head-logo-auto.css);
%%

Эти import’ы писались вручную.

Именование файлов ещё не устоялось, мы пробуем разные варианты.

=== Общепортальный фреймворк: Лего 1.2 (2008)
Чуть позже в рамках версии 1.2 был сделан рефакторинг и структура Лего изменилась.

%%hl xml
common/
    css/
    js/
    xml/
    xsl/
example/
    html/
service/
    auto/
        css/
        xml/
%%

Убрано разделение на util и block, весь общий CSS лежит в common/css.\\
От идеи выноса кода в Open Source на тот момент отказались. Вернулись к ней только через два года.

%%hl xml
common/
    css/
        b-dropdown/
            arr/
                b-dropdown.arr.css
                b-dropdown.arr.ie.css
                b-dropdown.css
                b-dropdown.ie.css
%%

Файлы для MSIE переименованы, было -ie.css, стало .ie.css.
Расширения у файлов теперь могут быть из нескольких слов.

Всё что было в опциональном CSS (файлах ##b-dropdown_arr.css##)
вынесено в директории (##arr/b-dropdown.arr.css##).\\
В основном файле блока стало меньше кода.

Для модификации постфиксом вместо минуса начали использовать подчёркивание.\\
Это позволило визуально отделить имя блока от модификатора, что
потом пригодилось при реализации инструментов, помогающих работать с кодом.

===БЭМ
В марте 2009 выходит версия Лего 2.0.\\
Этим событием заканчивается «Вёрстка независимыми блоками» и начинается «БЭМ».

====Лего 2.0, 2009
Что же принципиально изменилось с выходом версии 2.0?

Самое главное изменение -- мы вывели вперёд блоки, а не технологии.
Блоки стали первичны, а технологии их реализации -- вторичны.

Реализация блока делалась в отдельной директории, а технологии --
это файлы внутри неё. В том числе появилась документация к блоку — это файл
##.wiki## внутри блока.

Какими терминами мы тогда оперировали?

=====Терминология
##Независимый блок##, который может быть использован в любом месте страницы.\\
В XML он представлен тегом в неймспейсе lego.

XML:

%%hl xml
<lego:l-head>
<lego:b-head-logo>
%%

В HTML класс у блока, такой же, как имя этого тега.

HTML:

%%hl xml
<table class="l-head">
<div class="b-head-logo">
%%

CSS:

%%hl xml
.l-head
.b-head-logo
%%

Все файлы (css, js, html, xsl), относящиеся к блоку, кладутся в его директорию:

%%hl xml
    common/
        block/
            b-head-logo/
                b-head-logo.css
                b-head-logo.xsl
                b-head-logo.js
                b-head-logo.wiki
%%

Элементы в XML пишутся в неймспейсе lego без префикса:

%%hl xml
<lego:b-head-logo>
    <lego:name/>
</lego:b-head-logo>
%%

Класс в HTML — тоже без префикса.

%%hl xml
<div class="b-head-logo">
    <span class="name">Авто</span>
</div>

.b-head-logo .name { ... }
%%

Файлы для вложенного элемента кладутся в отдельную директорию.

%%hl xml
common/
    block/
        b-head-logo/
            name/
                b-head-logo.name.css
                b-head-logo.name.png
                b-head-logo.name.wiki
%%

Модификаторы в XML представлены атрибутами в неймспейсе lego:

%%hl xml
<lego:b-head-tabs lego:theme="grey">
%%

В HTML используется дополнительный класс.

%%hl xml
<div class="b-head-tabs b-head-tabs_grey">

.b-head-tabs_grey { ... }
%%

Файлы для модификатора кладутся в отдельную директорию, с
подчёркиванием в начале имени:

%%hl xml
common/
    block/
        b-head-logo/
            _theme/
                b-head-logo_gray.css
                b-head-logo_gray.png
                b-head-logo_gray.wiki
%%

===== Декларация используемых блоков
Все лего-компоненты проекта описываются в XML-файле.

%%hl xml
<lego:page>
    <lego:l-head>
        <lego:b-head-logo>
            <lego:name/>
        </lego:b-head-logo>

        <lego:b-head-tabs type="search-and-content"/>
%%

Из него генерируются CSS-файлы.

%%hl xml
@import url(../../common/block/global/_type/global_reset.css);
@import url(../../common/block/l-head/l-head.css);
@import url(../../common/block/b-head-logo/b-head-logo.css);
@import url(../../common/block/b-head-logo/name/b-head-logo.name.css);
@import url(../../common/block/b-head-tabs/b-head-tabs.css);
@import url(../../common/block/b-dropdown/b-dropdown.css);
@import url(../../common/block/b-dropdown/text/b-dropdown.text.css);
@import url(../../common/block/b-pseudo-link/b-pseudo-link.css);
@import url(../../common/block/b-dropdown/arrow/b-dropdown.arrow.css);
@import url(../../common/block/b-head-search/b-head-search.css);
@import url(../../common/block/b-head-search/arrow/b-head-search.arrow.css);
@import url(../../common/block/b-search/b-search.css);
@import url(../../common/block/b-search/input/b-search.input.css);
@import url(../../common/block/b-search/sample/b-search.sample.css);
@import url(../../common/block/b-search/precise/b-search.precise.css);
@import url(../../common/block/b-search/button/b-search.button.css);
@import url(../../common/block/b-head-userinfo/b-head-userinfo.css);
@import url(../../common/block/b-head-userinfo/user/b-head-userinfo.user.css);
@import url(../../common/block/b-user/b-user.css);
@import url(../../common/block/b-head-userinfo/service/b-head-userinfo.service.css);
@import url(../../common/block/b-head-userinfo/setup/b-head-userinfo.setup.css);
@import url(../../common/block/b-head-userinfo/region/b-head-userinfo.region.css);
@import url(block/b-head-logo/b-head-logo.css);
@import url(block/b-head-search/b-head-search.css);
%%

Из этого файла видно, что сначала идёт общий код,
а потом добавляются стили, чтобы привести лего-блоки к дизайну проекта.

Имена файлов элементов пишутся через точку: ##b-head-logo.name.css##

Из XML-декларации генерируются и JS-файлы.

%%hl js
include("../../common/block/i-locale/i-locale.js");
include("../../common/block/b-dropdown/b-dropdown.js");
include("../../common/block/b-search/sample/b-search.sample.js");
include("../../common/block/b-head-userinfo/user/b-head-userinfo.user.js");
%%

А также XSL-файлы.

%%hl xml
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:import href="../../common/block/i-common/i-common.xsl"/>
<xsl:import href="../../common/block/i-items/i-items.xsl"/>
<xsl:import href="../../common/block/l-head/l-head.xsl"/>
<xsl:import href="../../common/block/b-head-logo/b-head-logo.xsl"/>
<xsl:import href="../../common/block/b-head-logo/name/b-head-logo.name.xsl"/>
<xsl:import href="../../common/block/b-head-tabs/b-head-tabs.xsl"/>
<xsl:import href="../../common/block/b-dropdown/b-dropdown.xsl"/>
<xsl:import href="../../common/block/b-pseudo-link/b-pseudo-link.xsl"/>
<xsl:import href="../../common/block/b-head-search/b-head-search.xsl"/>
<xsl:import href="../../common/block/b-search/b-search.xsl"/>
<xsl:import href="../../common/block/b-search/input/b-search.input.xsl"/>
<xsl:import href="../../common/block/b-search/sample/b-search.sample.xsl"/>
<xsl:import href="../../common/block/b-search/precise/b-search.precise.xsl"/>
<xsl:import href="../../common/block/b-search/button/b-search.button.xsl"/>
<xsl:import href="../../common/block/b-head-userinfo/b-head-userinfo.xsl"/>
<xsl:import href="../../common/block/b-user/b-user.xsl"/>
<xsl:import href="../../common/block/b-head-userinfo/service/b-head-userinfo.service.xsl"/>
<xsl:import href="../../common/block/b-head-userinfo/setup/b-head-userinfo.setup.xsl"/>
<xsl:import href="../../common/block/b-head-userinfo/region/b-head-userinfo.region.xsl"/>

</xsl:stylesheet>
%%

Мы перестали писать эти файлы руками, началась генерация кода.

==== Скорость селекторов, 2009

При реализации новой версии Яндекс.Почты была задача сделать
её такой быстрой как программа на компьютере.

При решении этой задачи начали использовать XSL в браузере (и
подгружать по сети XML, необходимый для отрисовки данных на странице)
и столкнулись с проблемой, что трансформации отрабатывают быстро,
но вставка в DOM полученного результата происходит очень медленно.
При этом, если отключить CSS — всё происходит быстро.

Начали исследовать эту проблему и пришли к тому, что тормозят селекторы
CSS, которые при большом DOM-дереве и большой таблице стилей оказывают
существенное влияние на скорость отрисовки браузером страницы.

Результаты исследования подробно описаны в статье
((http://clubs.ya.ru/bem/replies.xml?item_no=338)).

Мы поняли, что решение этой проблемы у нас есть давно -- это
((http://clubs.ya.ru/bem/replies.xml?item_no=338 абсолютно-независимые блоки)).

Мы переделали все блоки в Лего на АНБ нотацию и с тех пор пишем блоки так, чтобы
у каждого DOM-узла был свой class (на который можно навесить стили) и не
используемся Tag Rules в CSS.\\
В классы элементов вносится имя блока, селекторы получаются простыми и быстрыми.

%%hl xml
<div class="b-head-logo">
    <span class="b-head-logo__name">
        Авто
    </span>
</div>
%%

====Стабилизация нотации
Постепенно мы пришли к тому, что нотация в коде и структура на файловой
системе устоялась и с тех пор уже не меняется.

В именах файлов разделитель . был заменён на __. Было ##b-block.elem.css##,
стало ##b-block__elem.css##. Теперь они совпадают с CSS-селекторами.

Были реализованы модификаторы у элементов по аналогии с модификаторами блоков.
##.b-block__elem_theme_green## по аналогии с ##.b-block_theme_green##.

В имя файла модификатора и в его класс внесён тип модификатора.
Было ##.b-menu__item_current##, стало ##.b-menu__item_state_current##.\\
Причина этого изменения — работа с модификаторами из JS.

===Open Source (2010)

В 2010 году мы создали организацию ((https://github.com/bem bem на github’е)),
чтобы вести разработку в open source.

====Библиотека bem-bl
Мы начали выносить блоки из Лего в ((https://github.com/bem/bem-bl bem-bl)),
проводя одновременно с этим рефакторинг.\\
Вместе с выносом блоков публиковали информацию про них в клубе:
((http://clubs.ya.ru/bem/posts.xml?tag=8486525)).

Работы по выносу блоков в Open Source пока не закончены.

====Инструменты
Начали реализацию инструментов ((https://github.com/bem/bem-tools bem-tools)),
которые помогают работать с файлами по БЭМ-методу.\\
Инструменты реализуются на JavaScript под Node.js.

Директории с реализацией блоков стали называть «уровнем переопределения».

Например, на проекте может быть:

 1. публичная библиотека блоков с github
 1. внутренняя библиотека lego
 1. и блоки самого проекта

%%hl xml
bem-bl/
    b-logo/
lego/
    b-logo/
auto/
    blocks/
        b-logo/
%%

На уровне переопределения можно задать другую схему
именования папок/файлов, отличную от нашей.\\
Для этого нужно сконфигурировать уровень:

%%hl xml
.bem/
    level.js
%%

Например, вы можете задать другие разделители между именем блока
и элемента, или не раскладывать всё по директориям, а сделать
плоскую структуру из файлов.

==== Шаблонизатор BEMHTML
После экспериментов с разными шаблонизаторами, был разработан
шаблонизатор BEMHTML.

Этот шаблонизатор

 1. позволяет писать шаблоны в БЭМ-терминах
 1. доопределять их на уровнях переопределения
 1. исполнять эти шаблоны, как на сервере, так и в браузере, поскольку
 шаблоны компилируются в простой и быстрый JavaScript

О BEMHTML есть много информации в клубе на Яру:

 * ((clubs.ya.ru/bem/replies.xml?item_no=898))
 * ((clubs.ya.ru/bem/replies.xml?item_no=899))
 * ((clubs.ya.ru/bem/replies.xml?item_no=1153))
 * ((clubs.ya.ru/bem/replies.xml?item_no=1172))
 * ((clubs.ya.ru/bem/replies.xml?item_no=1391))

===Варианты использования БЭМ

Как вы можете видеть, БЭМ не появился сразу. У нас был долгий период
проб и подбора наиболее подходящего нам варианта.

Но хочу обратить внимание, что всё это время это был БЭМ.

То, что мы используем сейчас — не единственно верное решение. Наоборот,
вы можете использовать БЭМ на своих проектах в том объёме, в
котором он принесёт наибольшую пользу.

БЭМ методология очень гибкая и позволяет вам настраивать её под свои процессы, под свои текущие технологии.

Давайте посмотрим на примерах.

====Блоки в одном файле
У вас есть проект, в котором вы хотите применить БЭМ
для вёрстки и ни для чего более.

Хорошо, мы тоже с этого начинали.

Выбирайте подходящую вам схему...

Например, с префиксами и каскадом.

%%hl xml
.b-block
.b-block .elem
.b-block_size_l
.b-block .elem_size_l
%%

Или задайте класс каждому DOM-узлу и используйте абсолютно-независимые блоки.

%%hl xml
.b-block
.b-block__elem
.b-block_size_l
.b-block__elem_size_l
%%

Или можно убрать префиксы.

%%hl xml
.block
.block__elem
.block_size_l
.block__elem_size_l
%%

И начинайте делать вёрстку на проекте по БЭМ.

Используйте самую простую схему на файловой системе, когда реализация блоков лежит в одном файле.

%%hl xml
myfacebook/
    myfacebook.css
    myfacebook.js
    myfacebook.html
%%

При использовании этого варианта всё делается руками, без bem-tools.

====Блоки в директории
Когда вы поймёте, что ваш проект вырос, можно начать раскладывать
реализацию блоков по файлам и использовать сборку.

%%hl xml
blocks/
    b-myblock.css
    b-myblock.js
    b-yourblock.css
    b-yourblock.js
%%

В этом случае можно начинать использовать bem-tools для сборки проекта.

====Не обязательное в файлах
Если в ваших блоках есть элементы/модификаторы, которые используются не на всех страницах,
можно вынести их реализацию в отдельные файлы, чтобы подключать только то, что нужно.

%%hl xml
blocks/
    b-myblock/
        b-myblock_mod_val1.css
        b-myblock__opt-elem.css
        b-myblock__opt-elem_mod_val1.css
        b-myblock.css
%%

====Модификаторы в директориях
Если модификаторов много, для каждого можно сделать отдельную директорию.

%%hl xml
blocks/
    b-myblock/
        _mod/
            b-myblock_mod_val1.css
            b-myblock__opt-elem.css
            b-myblock__opt-elem_mod_val1.css
        b-myblock.css
%%

Это разгрузит корневую директорию блока.

====Опциональные элементы в директориях
Предпоследний по сложности вариант, когда в директории выносятся ещё и
необязательные элементы, а код обязательных элементов лежит в основных файлах блока.

%%hl xml
blocks/
    b-myblock/
        _mod/
            b-myblock_mod_val1.css
        __opt-elem/
            b-myblock__opt-elem.css
        b-myblock.css
%%

Мы используем сейчас именно этот вариант при разработке Лего и bem-bl.

====ВСЕ элементы/модификаторы в директориях

Самый сложный в разработке, но самый понятный вариант по конечной структуре,
когда ВСЕ элементы блока и ВСЕ модификаторы имеют свои директории.

%%hl xml
blocks/
    b-myblock/
        _mod/
            b-myblock_mod_val1.css
        __elem/
           b-myblock__elem.css
        b-myblock.css
%%

Этот вариант очень наглядный, при взгляде на файловую систему можно увидеть всю структуру блока.

Мы сейчас спорим, надо нам переходить на него в Лего или нет.Ф

===Итог
Итак, давайте подведём итог.

БЭМ -- это методология организации работы над проектом, которая
позволяет команде работать c единым кодом и говорить на одном языке.

При этом нет единственно правильного варианта и мы не стремимся его получить.

Наоборот, мы рассматриваем БЭМ как набор правил.\\
Каждая конкретная команда встраивает его в свой процесс
разработки и использует так, как им удобно.
