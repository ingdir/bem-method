==The History of BEM

Once upon a time, in a distant country far-far away, an IT company named Yandex started developing web search and affiliated services. Time went by and services were growing, and more and more frontend developers put their tireless efforts into improving the ecosystem of Yandex. Great things they did, and amazing tools they built, making their developers' lives easier, and times now have come to share that knowledge with the community, to embrace the magic power of Open Source and benefit all good people around.

This article tells about Yandex frontend developers constantly revising and improving the way they build web pages. Frontend developers are well known for their enormous curiosuty (that often brings innovation) and their remarkable lazyness that makes them devise sophisticated systems to save the precious time, to unify and automate everything.

This is how many exciting things were born into life, but now let's travel back in time to 2005 and sneak a peek over a shoulder of a really-really-busy Yandex frontend developer, and thus see...

=== ...Where It All Began

Back in 2005, a typical Yandex project contained a set of static HTML pages that served as a base reference for creating advanced templates like XSL stylesheets. These pages were in a separate folder and looked like this after a checkout:

%%hl xml
about.html
index.html
…
project.css
project.js
i/
    yandex.png
%%

There was a static HTML file for each page, with all the CSS pushed into a single stylesheet, ##project.css##, and all Javascript placed in a single ##project.js##; both files were shared between project pages. At those times, JavaScript was only sparsely applied to some controls, so all the interaction magic for the whole project could fit comfortably into a single small file. Images were placed into a separate folder, as they were numerous. With IE 5 roaming in the wild and no CSS3, images were used for all sorts of eye-candy, even for creating rounded corners (although none of the youngest web developers would probably believe me :)).

To keep some structure, style definitions for different page sections were separated using plain CSS comments like this:


%%hl xml
/* Content container (begin) */
    #body
        {
            font: 0.8em Arial, sans-serif;

            margin: 0.5em 1.95% 0.5em 2%;
        }
/* Content container (end) */

/* Graphical banner (begin) */
    .banner
        {
            text-align: center;
        }

    .banner a
        {
            text-decoration: none;
        }
/* Graphical banner (end) */
%%

Both IDs and classnames were used in the HTML markup.

Static HTML was manually copied into production XSL stylesheets, and all changes were synced two-way, manually. That was hard, and even when it wasn't hard, it was dull.

===Mid-scale projects

At the beginning of 2006, the first version of Yandex.Music had been under heavy development. Multiple pages, each unlike the other, didn't fit well into familiar simplistic concepts. Dozens of CSS classes you had to invent meaningful names for, a growing number of unintentional dependencies spread along the project -- all that called for a better solution.

Typical piece of CSS code from those days:

%%hl xml
    /* Albums (begin) */
        .result .albums .info
            {
                padding-right: 8.5em;
            }

        .result .albums .title
            {
                float: left;

                padding-bottom: 0.3em;
            }

        .result .albums .album .listen
            {
                float: left;

                padding: 0.3em 1em 0 1em;
            }

        .result .albums .album .buy
            {
                float: left;

                padding: 0.4em 1em 0 1.6em;
            }

        .result .albums .info i
            {
                font-size: 85%;
            }
    /* Albums (end) */
%%

See that long cascade rules are used throughout the code.

Have another look:

%%hl xml
    /* Background images (begin) */
        .b-foot div
            {
                height: 71px;

                background: transparent url(../i/foot-1.png) 4% 50% no-repeat;
            }

        .b-foot div div
            {
                background-position: 21%;
                background-image: url(../i/foot-2.png);
            }

        .b-foot div div div
            {
                background-position: 38%;
                background-image: url(../i/foot-3.png);
            }

        .b-foot div div div div
            {
                background-position: 54%;
                background-image: url(../i/foot-4.png);
            }

        .b-foot div div div div div
            {
                background-position: 71%;
                background-image: url(../i/foot-5.png);
            }

        .b-foot div div div div div div
            {
                background-position: 87%;
                background-image: url(../i/foot-6.png);
            }
    /* Background images (end) */
%%

See that ##id## and tag names selectors are used in many rules.

At the same time, even bigger project was started ((http://wow.yandex.ru Яру)) -- a blogging platform, a place for people to interact, to share, to read and to engage.\\
There were dozens of various pages to support, and with the old-fashioned approach the code run out of control on many levels.

====Blocks To The Rescue
We needed to specify a data domain for managing page interface objects. This was a methodology thing, we needed to put more clarity into the way we work with concepts like ##class##, ##tag##, ##visual component## etc.

A new term was created: ##block##. Block is a part of a page design or layout having its specific and unique meaning defined either semantically, or visually.

CSS classes for blocks got prefixes (##b-##, ##c-##, ##g-##) to provide sort of a namespace emulation in CSS. The naming convention itself was changed later, here's the initial list explained:

 * **b-**  block\\
   an independent block, placed on a page wherever you need it
 * **с-**  control\\
   a control (an independent block) with a JavaScript object bound to it
 * **g-**  global\\
   a global definition, used sparingly and always defined for a specific, unique reason; the number of these definitions was kept at a minimum.

Some suffixes were employed as well, e.g.:
 * **-nojs**   no javascript\\
   Style rule to be applied with JavaScript turned off.
   The onload callback may contain ##init()## function call that removes these suffixes from all objects, thus semantically marking them up as "JavaScript-enabled".

====What's Inside?

In a block, some nodes had a distinct classname assigned to them. This not only facilitated the creation of tagname-independent CSS, but also added semantically meaningful roles to each node. They were named "block elements", or simply "elements".

The core distinction between a block and an element is the element's inability to exist out of its parent block's context. As long as you cannot separate something from a block, it's an element; when you can, then it's probably another block that needs another name.

At first, elements could have existed only inside their block's container; later, a technique was provided to place some elements outside and still keep a block consistent.

In the stylesheets, elements with lots of CSS got extra indentation and were wrapped in comments:

%%hl xml
    /* Head (begin) */
        .b-head { … }

        /* Logo (begin) */
            .b-head .logo { … }
            .b-head .logo a { … }
        /* Logo (end) */

        /* Right side (begin) */
        .b-head .right { … }

            /* Info (begin) */
                .b-head .info { … }
                .b-head .info .exit a { … }
            /* Info (end) */

            /* Search (begin) */
                .b-head .search { … }
                .b-head .search div div, .b-head .search div div i { … }
            /* Search (end) */
        /* Right side (end) */
    /* Head (end) */
%%

====Project File Structure Evolves
Larger projects took advantage of a more granular file structure. Our tremendous love for IE produced specific CSS files with workarounds and hacks that were loaded with conditional comments. JavaScript was employed even more, we got optional components and libraries. So, CSS and JS files got their separate folders.

%%hl xml
index.html
css/
    yaru.css
    yaru-ie.css
js/
    yaru.js
i/
    yandex.png
%%

MSIE-specific hacks could go into the main CSS file (##yaru.css##) if they were in compliance with the CSS standards:

%%hl xml
    /* Common definitions (begin) */
        body
            {
                font-family: Arial, sans-serif;
                font-size: 0.8em;

                padding: 0 0 2em 0;
                background: #fff;
            }

        * html body
            {
                font-size: 80%;
            }
%%

Non-valid workarounds were put in a standalone ##yaru-ie.css## (loaded with IE-only conditional comments).

%%hl xml
    /* Common blocks (begin) */
        /* Artist (begin) */
            .b-artist .i i
                {
                    top: expression(7 + (90 - this.parentNode.getElementsByTagName('img')[0].height)/2);
                    filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='../i/sticker-lt.png', sizingMethod='crop');
                }
%%

===Building Up A Framework: The Beginning

Designing similar projects eventually leads to re-creating the same blocks over and over again. Provided the fact that Yandex is in fact a portal having more than 100 services sharing the same corporate style, careless copy/paste from project to project doesn't work well for obvious reasons. So at first we had compiled a collection of reusable components, which inside Yandex was referred to as "common blocks library", or simply "the Common".

First page fragments to be unified were: header, footer and some typographic CSS definitions. The corresponding files were hosted on an internal dedicated server (**common.cloudkill.yandex.ru** in the listings below).

Styles could be imported from that server:

%%hl xml
@import url(http://common.cloudkill.yandex.ru/css/global.css);
@import url(http://common.cloudkill.yandex.ru/css/head/common.css);
@import url(http://common.cloudkill.yandex.ru/css/static-text.css);
@import url(http://common.cloudkill.yandex.ru/css/foot/common-absolute.css);
@import url(http://common.cloudkill.yandex.ru/css/foot/common-absolute-4-columns.css);
@import url(http://common.cloudkill.yandex.ru/css/list/hlist.css);
@import url(http://common.cloudkill.yandex.ru/css/list/hlist-middot.css);
@import url(http://common.cloudkill.yandex.ru/css/dropdown/dropdown.css);
@import url(http://common.cloudkill.yandex.ru/css/dropdown/dropdown-arrow.css);
@import url(slider.css);

/* Header (begin) */
    /* Service (begin) */
        .b-head .service h1 { … }
        .b-head .service h1, .b-head .service h1 a, .b-head .service h1 b { … }
%%

Obviousy, too many imports! So, we decided to pre-compile styles (and later, JS files) before deployment; the compilation replaces ##@import## directives with the actual contents of external files (this is called ##inlining##) and performs more optimizations. Our internal inlining tool evolved from a simple wrapper script into an open source project ((https://github.com/veged/borschik borschik)); try it out!

===Independent Blocks as a Concept
By the fall of 2007, the principles we were using to build our pages took their shape to produce the Independent Block concept, which was featured at the ClientSide'2007 conference in Moscow, Russia.

In that presentation, the first attempt to define a ##block## has been made.

==== Blocks: The Declaration of Independence
In or attempt to produce a formal (in fact, semi-formal) declaration of a ##block##, the following 3 principles were highlighted:

 1. Only classnames (not IDs) are used to describe styles;
 1. Each block's classname has a prefix;
 1. Any CSS rules except  must belong to a block.

As soon as unique IDs are dropped, the same block can be used on the same page more than once. This also allows two or more classes to co-exist on the same DOM node, which turned out to be quite useful later.

=====Blocks Simple and Compound: The Misclassification

We defined simple blocks as not being able to contain another blocks anywhere inside their markup.
Compound blocks were allowed (or sometimes, required) to have nested blocks embedded.

This classification was naive; even the simplest blocks sometimes were wrapped around other blocks and had to be "upgraded" and refactored to fit the new role. This misclassification in fact had struck back in so many cases that we had finally accepted the opposite principle: any block should allow for arbitrary content to be embedded, whenever possible.

=====Completely Independent Blocks
CSS definitions aren't bulletproof when we mix a lot of styled content originating from different sources on a single web page. In complex layouts, blocks may alter each other's appearance because of element names conflicts. Tagname-based CSS rules may match more tags than we intended them to. As soon as we had to fight these and similar bugs in production, a strict version of an independent block (named Absolutely Independept Block, abbreviated AIB) was defined with the following extra rules:

 1. never match CSS to tagnames, use classnames for everything:\\
    ##.b-user b -> .b-user .first-letter##
 2. classnames for block elements must be prefixed with the parent block name:\\
    ##.b-user .first-letter -> .b-user-first_letter##

Such classnames tend to be much longer, and the resulting HTML code is considerably bigger in size.\\
This was the main reason why AIB was considered a "costly solution" to be used more as a remedy, not as an everyday practice.

=====Prefixes
As everybody is aware nowadays, giving names to variables is one of the most difficult problems in development, ever. We approached it cautiously, and invented four prefixes allowed for block names, each with its own semantics.

 * **b-**\\
   common blocks
 * **h-**\\
   holsters, used for gluing several elements together
 * **l-**\\
   layout grids
 * **g-**\\
   global styles

=====Modifications

##Modification## can be defined as a specific state of a block, or a flag that holds some specific property.
This is best explained with an example: a block representing a button may have three default sizes: small, normal and big. Instead of creating 3 different blocks, you should assign a ##modification## to your block. The modification requirs a name (e.g. "size") and a value ("small", "normal" or "big").

There are two legitimate sources of modification for a block:

 1. Block may alter its presentation according to its placement in the layout.
    Such modification is called ##context-dependent##.
 1. An additional (postfixed) classname may change block's appearance. This is a context-independent (postfix-based) modification.\\
##class="b-block b-block-postfix"##

Context-independent modifications are added 

===Unified Portal-Wide Framework
At the beginning of 2008, Yandex had been going through a major review of its internal design policies and decided to prepare a brand book (for internal use) to enforce best practices in interface design.

This task was assigned to my team, and after some pondering of options, I decided to proceed with the one I was most proficient with: HTML and CSS code.\\
Interfaces evolve fast, and any attempt to describe interfaces with words and pictures will become obsolete even before completion. We needed a brand book that would represent our interfaces as they were: changing rapidly and still unified between different Yandex services and products.

Therefore, we decided that our interface brand book should be built with the same blocks we used to build our web sites. Blocks could be shared between projects and represent the latest in Yandex interface design.

We decided to build a portal-wide framework of blocks so all could both benefit from it and contribute back. The project was internally named ##Lego##.

====Lego Repository Structure, First Approach
The topmost level corresponded to various available ##implementations##:

%%hl xml
css/
html/
js/
xml/
xsl/
%%

Each implementation contained its own sub-structure of folders.

CSS went into 3 different folders:

%%hl xml
css/
    block/
        b-dropdown/
            b-dropdown.css
    service/
        auto/
            block/
                b-head-logo-auto.css
            head.css
    util/
        b-hmenu/
            b-hmenu.css
%%

 1. block -- blocks shared between services
 1. util -- general-purpose blocks ready to be opensourced
 1. service -- CSS styles for specific Yandex services, used for branding, header/footer etc.

HTML folder structure was identical to CSS:

%%hl xml
html/
    block/
        b-dropdown.html
    service/
        auto/
            l-head.html
    util/
        b-hmenu.html
%%

JavaScript was yet loosely-structured and used inconsistently between services:

%%hl xml
js/
    check-is-frame.js
    check-session.js
    clean-on-focus.js
    dropdown.js
    event.add.js
    event.del.js
%%

Each service had a corresponding XML file semantically describing its page header (and providing necessary project-specific data), which in conjunction with an XSL stylesheet generated the header HTML code.

%%hl xml
xml/
    block/
        b-head-tabs-communication.xml
        common-services.ru.xml
        head-messages.ru.xml
    service/
        auto/
            head.xml
%%

XSL templates for various blocks (one file per block) were placed in one folder:

%%hl xml
xsl/
    block/
        b-dropdown.xsl
        b-head-line.xsl
        i-common.xsl
        i-locale.xsl
        l-foot.xsl
        l-head.xsl
%%

What about integration?

Lego is linked to projects with the help of a version control feature known as ##svn:externals##.

When a package is built for production deployment, the external library (Lego) code is embedded into the package; this is similar to static library linking in compiled languages.

Lego provides an SVN branch for each of its major releases; sticking to a branch in svn:externals allow for hotfixes to arrive to a project; for extreme stability, project can freeze on a specific Lego revision. In either case, major versions switches can be prepared and made whenever necessary.

This simple technique proved quite flexible and is employed up to this day by many Yandex services.

=====Per-Page Files
Files linked from web pages were mostly importing corresponding block implementations from the Lego folder structure.

%%hl xml
@import url(../../block/l-head/l-head.css);
@import url(../../block/b-head-logo/b-head-logo.css);
@import url(../../block/b-head-logo/b-head-logo_name.css);
@import url(block/b-head-logo-auto.css);
%%

The consistency of import directives was manually mantained.

At that point, we didn't yet come to a unified file naming convention and tried several approaches.

=== Portal-Wide Framework Lego 1.2 (2008)
Upon releasing Lego version 1.2, the code had been refactored and folder structure had changed.

%%hl xml
common/
    css/
    js/
    xml/
    xsl/
example/
    html/
service/
    auto/
        css/
        xml/
%%

Blocks previously separated and placed in ##util## and ##block## folders are now combined. Common styles shared by most blocks are stored in common/css.\\
We had been pondering the possibility of open-sourcing the code but postponed it until two years later.

%%hl xml
common/
    css/
        b-dropdown/
            arr/
                b-dropdown.arr.css
                b-dropdown.arr.ie.css
                b-dropdown.css
                b-dropdown.ie.css
%%

MSIE-specific styles had been renamed from *-ie.css to *.ie.css.

All contents of optional CSS files (such as ##b-dropdown_arr.css##) had been moved into separate folders (##arr/b-dropdown.arr.css##).\\

For classname-based modification of a block, the underscore was assigned as a separator, replacing a single dash that was used previously.\\
This made a block name visually separated from a modificator name, and proved quite useful while developing automatic code tools, as it allowed for unambiguous search and pattern matching.

===BEM, est. 2009
In March of 2009, Lego 2.0 had been released.\\
That event marks the end of the "independent blocks" epoch and begins formation of the BEM methodology.

====Lego 2.0 in 2009
What was the key update the 2.0 version had delivered?

What really changed our understanding of the methodology was the primacy of ##block## regardless of the underlying technologies. We think of blocks first and implementation details are secondary.

Each block has itself implemented in a separate folder; each technology (CSS, JS, XSL etc.) being represented by a separate file. Documentation just gets its own file type such as ##.wiki##.

What additional terms did we operate on at that time?

=====Terminology Excerpts
##Independent Block## may be used on any web page and placed anywhere in the layout.\\
In XML that we use to apply XSL stylesheets to, the block is represented by an XML tag in ##lego## namespace.

XML:

%%hl xml
<lego:l-head>
<lego:b-head-logo>
%%

In HTML, a block container gets a classname exactly corresponding to its name.

HTML:

%%hl xml
<table class="l-head">
<div class="b-head-logo">
%%

CSS:

%%hl xml
.l-head
.b-head-logo
%%

All block files (CSS, JS, HTML, XSL) are stored in the block's folder:

%%hl xml
    common/
        block/
            b-head-logo/
                b-head-logo.css
                b-head-logo.xsl
                b-head-logo.js
                b-head-logo.wiki
%%

In XML files that describe page structure, blocks are described with elements in ##lego## namespace; block name prefix is omitted:

%%hl xml
<lego:b-head-logo>
    <lego:name/>
</lego:b-head-logo>
%%

HTML classes inside the block have their prefixes omitted as well.

%%hl xml
<div class="b-head-logo">
    <span class="name">Авто</span>
</div>

.b-head-logo .name { ... }
%%

Files related to inner elements each get their own folder:

%%hl xml
common/
    block/
        b-head-logo/
            name/
                b-head-logo.name.css
                b-head-logo.name.png
                b-head-logo.name.wiki
%%

Modifiers in XML are specified as tag attributes in ##lego## namespace:

%%hl xml
<lego:b-head-tabs lego:theme="grey">
%%

In HTML, an extra classname is added:

%%hl xml
<div class="b-head-tabs b-head-tabs_grey">

.b-head-tabs_grey { ... }
%%

Modifier files (styles etc.) go into separate folders prefixed with an underscore:

%%hl xml
common/
    block/
        b-head-logo/
            _theme/
                b-head-logo_gray.css
                b-head-logo_gray.png
                b-head-logo_gray.wiki
%%

===== Declaring
All lego components used in a project are described in an XML file:

%%hl xml
<lego:page>
    <lego:l-head>
        <lego:b-head-logo>
            <lego:name/>
        </lego:b-head-logo>

        <lego:b-head-tabs type="search-and-content"/>
%%

This XML allows for CSS imports to be generated:

%%hl xml
@import url(../../common/block/global/_type/global_reset.css);
@import url(../../common/block/l-head/l-head.css);
@import url(../../common/block/b-head-logo/b-head-logo.css);
@import url(../../common/block/b-head-logo/name/b-head-logo.name.css);
@import url(../../common/block/b-head-tabs/b-head-tabs.css);
@import url(../../common/block/b-dropdown/b-dropdown.css);
@import url(../../common/block/b-dropdown/text/b-dropdown.text.css);
@import url(../../common/block/b-pseudo-link/b-pseudo-link.css);
@import url(../../common/block/b-dropdown/arrow/b-dropdown.arrow.css);
@import url(../../common/block/b-head-search/b-head-search.css);
@import url(../../common/block/b-head-search/arrow/b-head-search.arrow.css);
@import url(../../common/block/b-search/b-search.css);
@import url(../../common/block/b-search/input/b-search.input.css);
@import url(../../common/block/b-search/sample/b-search.sample.css);
@import url(../../common/block/b-search/precise/b-search.precise.css);
@import url(../../common/block/b-search/button/b-search.button.css);
@import url(../../common/block/b-head-userinfo/b-head-userinfo.css);
@import url(../../common/block/b-head-userinfo/user/b-head-userinfo.user.css);
@import url(../../common/block/b-user/b-user.css);
@import url(../../common/block/b-head-userinfo/service/b-head-userinfo.service.css);
@import url(../../common/block/b-head-userinfo/setup/b-head-userinfo.setup.css);
@import url(../../common/block/b-head-userinfo/region/b-head-userinfo.region.css);
@import url(block/b-head-logo/b-head-logo.css);
@import url(block/b-head-search/b-head-search.css);
%%

This example shows that common styles are imported first; then, project styles add extra definitions or redefine some of the common blocks. This makes project-specific changes possible while maintaining a common shared codebase.

Filenames use dot as a separator: ##b-head-logo.name.css##

Same XML declarations allow for JS includes to be autogenerated.

%%hl js
include("../../common/block/i-locale/i-locale.js");
include("../../common/block/b-dropdown/b-dropdown.js");
include("../../common/block/b-search/sample/b-search.sample.js");
include("../../common/block/b-head-userinfo/user/b-head-userinfo.user.js");
%%

XSL templates imports are autogenerated as well, using the same XML-based definitions:

%%hl xml
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:import href="../../common/block/i-common/i-common.xsl"/>
<xsl:import href="../../common/block/i-items/i-items.xsl"/>
<xsl:import href="../../common/block/l-head/l-head.xsl"/>
<xsl:import href="../../common/block/b-head-logo/b-head-logo.xsl"/>
<xsl:import href="../../common/block/b-head-logo/name/b-head-logo.name.xsl"/>
<xsl:import href="../../common/block/b-head-tabs/b-head-tabs.xsl"/>
<xsl:import href="../../common/block/b-dropdown/b-dropdown.xsl"/>
<xsl:import href="../../common/block/b-pseudo-link/b-pseudo-link.xsl"/>
<xsl:import href="../../common/block/b-head-search/b-head-search.xsl"/>
<xsl:import href="../../common/block/b-search/b-search.xsl"/>
<xsl:import href="../../common/block/b-search/input/b-search.input.xsl"/>
<xsl:import href="../../common/block/b-search/sample/b-search.sample.xsl"/>
<xsl:import href="../../common/block/b-search/precise/b-search.precise.xsl"/>
<xsl:import href="../../common/block/b-search/button/b-search.button.xsl"/>
<xsl:import href="../../common/block/b-head-userinfo/b-head-userinfo.xsl"/>
<xsl:import href="../../common/block/b-user/b-user.xsl"/>
<xsl:import href="../../common/block/b-head-userinfo/service/b-head-userinfo.service.xsl"/>
<xsl:import href="../../common/block/b-head-userinfo/setup/b-head-userinfo.setup.xsl"/>
<xsl:import href="../../common/block/b-head-userinfo/region/b-head-userinfo.region.xsl"/>

</xsl:stylesheet>
%%

Code autogeneration was an important step forward; from this point onwards, we don't have to maintain depenpencies manually.

==== CSS Selector Speed Revisited, 2009

During major redesign of Yandex.Mail service in 2009, interface responsiveness and overall speed were key factors. It was our goal to release a web application that feels as fast as a piece of desktop software, and maybe even faster.

Client-side (in-browser) XSL transformations were employed as a main templating solution (XML with all the data was loaded separately). XSL transforms were applied really fast, but the resulting HTML code took significant time to be appended to the page DOM. However, disabling all CSS made this problem go away magically.

While studying various factors that could have affected rendering speed, CSS selectors were identified as a major source of the slowdown. The bigger the DOM tree and the CSS stylesheet, the longer it takes for all CSS rules to be applied.

These's a summary of our study available (in Russian):
((http://clubs.ya.ru/bem/replies.xml?item_no=338)).

And it turned out that there's a way to make that CSS many times faster: we should switch to simple selectors and eliminate CSS cascade wherever possible. Selectors based on a single classname are quick and browser handles them with ease. We already had a solution that could use such selectors: the so-called 
((http://clubs.ya.ru/bem/replies.xml?item_no=338 completely independent blocks)).

All Lego blocks were refactored to follow the completely independent blocks restrictions. As soon as block name becomes a prefix of block element's classnames, most selectors require a single class query and work way more faster.

%%hl xml
<div class="b-head-logo">
    <span class="b-head-logo__name">
        Авто
    </span>
</div>
%%

====Establishing Naming Conventions
After several attempts of modifying the naming conventions, we agreed on some naming principles that hadn't changed since then.

In file names, the dot separator was replaced by double underscore __. Before: ##b-block.elem.css##,
after: ##b-block__elem.css##. File names were made consistent with CSS selectors.

Block's elements were allowed to have their own modifiers, too.

##.b-block__elem_theme_green## по аналогии с ##.b-block_theme_green##.

В имя файла модификатора и в его класс внесён тип модификатора.
Было ##.b-menu__item_current##, стало ##.b-menu__item_state_current##.\\
Причина этого изменения — работа с модификаторами из JS.

===Open Source (2010)

В 2010 году мы создали организацию ((https://github.com/bem bem на github’е)),
чтобы вести разработку в open source.

====Библиотека bem-bl
Мы начали выносить блоки из Лего в ((https://github.com/bem/bem-bl bem-bl)),
проводя одновременно с этим рефакторинг.\\
Вместе с выносом блоков публиковали информацию про них в клубе:
((http://clubs.ya.ru/bem/posts.xml?tag=8486525)).

Работы по выносу блоков в Open Source пока не закончены.

====Инструменты
Начали реализацию инструментов ((https://github.com/bem/bem-tools bem-tools)),
которые помогают работать с файлами по БЭМ-методу.\\
Инструменты реализуются на JavaScript под Node.js.

Директории с реализацией блоков стали называть «уровнем переопределения».

Например, на проекте может быть:

 1. публичная библиотека блоков с github
 1. внутренняя библиотека lego
 1. и блоки самого проекта

%%hl xml
bem-bl/
    b-logo/
lego/
    b-logo/
auto/
    blocks/
        b-logo/
%%

На уровне переопределения можно задать другую схему
именования папок/файлов, отличную от нашей.\\
Для этого нужно сконфигурировать уровень:

%%hl xml
.bem/
    level.js
%%

Например, вы можете задать другие разделители между именем блока
и элемента, или не раскладывать всё по директориям, а сделать
плоскую структуру из файлов.

==== Шаблонизатор BEMHTML
После экспериментов с разными шаблонизаторами, был разработан
шаблонизатор BEMHTML.

Этот шаблонизатор

 1. позволяет писать шаблоны в БЭМ-терминах
 1. доопределять их на уровнях переопределения
 1. исполнять эти шаблоны, как на сервере, так и в браузере, поскольку
 шаблоны компилируются в простой и быстрый JavaScript

О BEMHTML есть много информации в клубе на Яру:

 * ((clubs.ya.ru/bem/replies.xml?item_no=898))
 * ((clubs.ya.ru/bem/replies.xml?item_no=899))
 * ((clubs.ya.ru/bem/replies.xml?item_no=1153))
 * ((clubs.ya.ru/bem/replies.xml?item_no=1172))
 * ((clubs.ya.ru/bem/replies.xml?item_no=1391))

===Варианты использования БЭМ

Как вы можете видеть, БЭМ не появился сразу. У нас был долгий период
проб и подбора наиболее подходящего нам варианта.

Но хочу обратить внимание, что всё это время это был БЭМ.

То, что мы используем сейчас — не единственно верное решение. Наоборот,
вы можете использовать БЭМ на своих проектах в том объёме, в
котором он принесёт наибольшую пользу.

БЭМ методология очень гибкая и позволяет вам настраивать её под свои процессы, под свои текущие технологии.

Давайте посмотрим на примерах.

====Блоки в одном файле
У вас есть проект, в котором вы хотите применить БЭМ
для вёрстки и ни для чего более.

Хорошо, мы тоже с этого начинали.

Выбирайте подходящую вам схему...

Например, с префиксами и каскадом.

%%hl xml
.b-block
.b-block .elem
.b-block_size_l
.b-block .elem_size_l
%%

Или задайте класс каждому DOM-узлу и используйте абсолютно-независимые блоки.

%%hl xml
.b-block
.b-block__elem
.b-block_size_l
.b-block__elem_size_l
%%

Или можно убрать префиксы.

%%hl xml
.block
.block__elem
.block_size_l
.block__elem_size_l
%%

И начинайте делать вёрстку на проекте по БЭМ.

Используйте самую простую схему на файловой системе, когда реализация блоков лежит в одном файле.

%%hl xml
myfacebook/
    myfacebook.css
    myfacebook.js
    myfacebook.html
%%

При использовании этого варианта всё делается руками, без bem-tools.

====Блоки в директории
Когда вы поймёте, что ваш проект вырос, можно начать раскладывать
реализацию блоков по файлам и использовать сборку.

%%hl xml
blocks/
    b-myblock.css
    b-myblock.js
    b-yourblock.css
    b-yourblock.js
%%

В этом случае можно начинать использовать bem-tools для сборки проекта.

====Не обязательное в файлах
Если в ваших блоках есть элементы/модификаторы, которые используются не на всех страницах,
можно вынести их реализацию в отдельные файлы, чтобы подключать только то, что нужно.

%%hl xml
blocks/
    b-myblock/
        b-myblock_mod_val1.css
        b-myblock__opt-elem.css
        b-myblock__opt-elem_mod_val1.css
        b-myblock.css
%%

====Модификаторы в директориях
Если модификаторов много, для каждого можно сделать отдельную директорию.

%%hl xml
blocks/
    b-myblock/
        _mod/
            b-myblock_mod_val1.css
            b-myblock__opt-elem.css
            b-myblock__opt-elem_mod_val1.css
        b-myblock.css
%%

Это разгрузит корневую директорию блока.

====Опциональные элементы в директориях
Предпоследний по сложности вариант, когда в директории выносятся ещё и
необязательные элементы, а код обязательных элементов лежит в основных файлах блока.

%%hl xml
blocks/
    b-myblock/
        _mod/
            b-myblock_mod_val1.css
        __opt-elem/
            b-myblock__opt-elem.css
        b-myblock.css
%%

Мы используем сейчас именно этот вариант при разработке Лего и bem-bl.

====ВСЕ элементы/модификаторы в директориях

Самый сложный в разработке, но самый понятный вариант по конечной структуре,
когда ВСЕ элементы блока и ВСЕ модификаторы имеют свои директории.

%%hl xml
blocks/
    b-myblock/
        _mod/
            b-myblock_mod_val1.css
        __elem/
           b-myblock__elem.css
        b-myblock.css
%%

Этот вариант очень наглядный, при взгляде на файловую систему можно увидеть всю структуру блока.

Мы сейчас спорим, надо нам переходить на него в Лего или нет.Ф

===Итог
Итак, давайте подведём итог.

БЭМ -- это методология организации работы над проектом, которая
позволяет команде работать c единым кодом и говорить на одном языке.

При этом нет единственно правильного варианта и мы не стремимся его получить.

Наоборот, мы рассматриваем БЭМ как набор правил.\\
Каждая конкретная команда встраивает его в свой процесс
разработки и использует так, как им удобно.
